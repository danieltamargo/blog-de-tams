---
title: "Principios SOLID: CÃ³digo de calidad"
description: "Entendiendo los principios SOLID a travÃ©s de ejemplos de cÃ³digo divertidos"
date: "2024-11-10"
tags: ["programaciÃ³n", "diseÃ±o de software", "arquitectura", "tutorial"]
---
# Principios SOLID: CÃ³digo de calidad

Â¿Alguna vez has pensado en escribir cÃ³digo que no haga que tu â€œyoâ€ del futuro quiera viajar en el tiempo y pegarle al â€œyoâ€ actual? Â¡Llegan los principios SOLID al rescate! Vamos a explicarlos con algunos ejemplos divertidos.

## Principio de Responsabilidad Ãšnica (SRP)

Piensa en esto como la regla de â€œun solo trabajoâ€. Como un chef de pizzas que solo hace pizzas, y no intenta tambiÃ©n ser el camarero, el contable y el DJ.

```typescript
// ğŸš« Malo: Una clase haciendo de todo
class SuperHeroe {
  nombre: string;
  
  constructor(nombre: string) {
    this.nombre = nombre;
  }
  
  salvarElMundo() {
    // Luchando contra los malos
  }
  
  escribirInforme() {
    // Haciendo papeleo
  }
  
  gestionarRRPP() {
    // Atendiendo conferencias de prensa
  }
}
```

```typescript
// âœ… Bueno: Cada clase tiene una sola responsabilidad
class SuperHeroe {
  nombre: string;
  
  constructor(nombre: string) {
    this.nombre = nombre;
  }
  
  salvarElMundo() {
    // Solo luchando contra los malos ğŸ’ªğŸ¼
  }
}

class Reportero {
  // ... constructor, propiedades, etc.

  escribirInforme(heroe: SuperHeroe) {
    // Solo manejando el papeleo del hÃ©roe ğŸ“‹
  }
}

class GerenteRRPP {
  // ... constructor, propiedades, etc.

  gestionarRRPP(heroe: SuperHeroe) {
    // Solo manejando relaciones pÃºblicas del hÃ©roe ğŸ¤
  }
}
```

## Principio Abierto/Cerrado (OCP)

Las entidades de software deben estar abiertas para extensiÃ³n pero cerradas para modificaciÃ³n. Como bloques de LEGO: no rompes bloques existentes para hacer cosas nuevas, Â¡solo agregas mÃ¡s bloques!

```typescript
// ğŸš« Malo: Necesita modificar la clase para nuevas formas
class CalculadoraArea {
  calcularArea(figura: string, ancho: number, alto: number) {
    if (figura === 'rectÃ¡ngulo') {
      return ancho * alto;
    } else if (figura === 'cÃ­rculo') {
      return Math.PI * ancho * ancho;
    }
    // Â¡Hay que modificar esta clase para cada nueva figura!
  }
}
```

```typescript
// âœ… Bueno: Solo aÃ±ade nuevas figuras implementando la interfaz
interface Figura {
  calcularArea(): number;
}

class Rectangulo implements Figura {
  constructor(private ancho: number, private alto: number) {}
  
  calcularArea(): number {
    return this.ancho * this.alto;
  }
}

class Circulo implements Figura {
  constructor(private radio: number) {}
  
  calcularArea(): number {
    return Math.PI * this.radio * this.radio;
  }
}
```

## Principio de SustituciÃ³n de Liskov (LSP)

Si parece un pato, hace â€œcuacâ€ como un pato, pero necesita pilasâ€¦ Â¡probablemente tienes la abstracciÃ³n equivocada! Los subtipos deben poder sustituirse por sus tipos base sin cambiar el comportamiento esperado.

```typescript
// ğŸš« Malo: Â¡El pingÃ¼ino no puede volar!
class Ave {
  volar() {
    // ImplementaciÃ³n de vuelo
  }
}

class Pinguino extends Ave {
  volar() {
    throw new Error("Â¡Ayuda! Â¡No puedo volar!"); // No respeta LSP
  }
}
```

```typescript
// âœ… Bueno: JerarquÃ­a adecuada
interface Ave {
  mover(): void;
}

class AveVoladora implements Ave {
  mover() {
    this.volar();
  }
  
  private volar() {
    // ImplementaciÃ³n de vuelo
  }
}

class AveNadadora implements Ave {
  mover() {
    this.nadar();
  }
  
  private nadar() {
    // ImplementaciÃ³n de nado
  }
}
```

## Principio de SegregaciÃ³n de Interfaces (ISP)

No hagas que alguien pague por un menÃº completo cuando solo quiere un bocadillo. Divide las interfaces en partes mÃ¡s pequeÃ±as y especÃ­ficas.

```typescript
// ğŸš« Malo: Una sola interfaz grande
interface DispositivoInteligente {
  llamar(): void;
  enviarCorreo(): void;
  leerCorreo(): void;
  navegarInternet(): void;
  tomarFoto(): void;
  reproducirMusica(): void;
}
```

```typescript
// âœ… Bueno: Interfaces segregadas
interface Telefono {
  llamar(): void;
}

interface ClienteCorreo {
  enviarCorreo(): void;
  leerCorreo(): void;
}

interface NavegadorWeb {
  navegarInternet(): void;
}

interface Camara {
  tomarFoto(): void;
}

interface ReproductorMusica {
  reproducirMusica(): void;
}

// Ahora los dispositivos pueden implementar solo lo que necesitan
class Smartphone implements Telefono, ClienteCorreo, NavegadorWeb, Camara, ReproductorMusica {
  // ImplementaciÃ³n
}

class TelefonoViejo implements Telefono {
  // Solo funciÃ³n de llamada
}
```

## Principio de InversiÃ³n de Dependencias (DIP)

Los mÃ³dulos de alto nivel no deberÃ­an depender de los mÃ³dulos de bajo nivel. Ambos deberÃ­an depender de abstracciones. Como un enchufe de pared: no conectas tu portÃ¡til directamente a la planta de energÃ­a.

```typescript
// ğŸš« Malo: Dependencia directa en mÃ³dulo de bajo nivel
class ServicioNotificaciones {
  private enviadorCorreo = new EnviadorCorreo();
  
  enviarNotificacion(mensaje: string) {
    this.enviadorCorreo.enviarCorreo(mensaje);
  }
}
```

```typescript
// âœ… Bueno: Dependiendo de la abstracciÃ³n
interface EnviadorMensajes {
  enviar(mensaje: string): void;
}

class EnviadorCorreo implements EnviadorMensajes {
  enviar(mensaje: string) {
    // Enviar correo
  }
}

class EnviadorSMS implements EnviadorMensajes {
  enviar(mensaje: string) {
    // Enviar SMS
  }
}

class ServicioNotificaciones {
  constructor(private enviadorMensajes: EnviadorMensajes) {}
  
  enviarNotificacion(mensaje: string) {
    this.enviadorMensajes.enviar(mensaje);
  }
}
```

## ConclusiÃ³n

Seguir los principios SOLID puede parecer trabajo extra al principio, pero es como cepillarse los dientes: una pequeÃ±a inversiÃ³n diaria que evita problemas dolorosos mÃ¡s adelante. Recuerda:

- Responsabilidad Ãšnica: Una tarea por clase
- Abierto/Cerrado: AÃ±ade nuevas caracterÃ­sticas sin cambiar el cÃ³digo existente
- SustituciÃ³n de Liskov: Los subtipos deben poder sustituirse por sus tipos base
- SegregaciÃ³n de Interfaces: Mejor interfaces pequeÃ±as y especÃ­ficas que una grande
- InversiÃ³n de Dependencias: Depende de abstracciones, no implementaciones concretas

Â¡Feliz codificaciÃ³n! ğŸš€
